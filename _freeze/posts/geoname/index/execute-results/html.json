{
  "hash": "9013939a0511ac905ce89b31f017cd71",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Cleaning and standardising geographic names in R with `prep_geonames()`\"\nsubtitle: \"A hands-on workshop for systematic geographic name matching\"\nformat:\n  html:\n    self-contained: true\n    toc: true\n    toc-depth: 4\n    # html-math-method: katex\n    # css: styles.css\nauthor:\n  - Mohamed A Yusuf\ndate: \"2025-09-01\"\ncategories:\n - R\n - Data cleaning\n - Geospatial\n - GIS\neditor:\n  markdown:\n    wrap: 72\n---\n\n\n\n\n\\vspace{15pt}\n\\renewcommand\\contentsname{}\n\\setcounter{tocdepth}{2}\n\\hrule\n\\tableofcontents\n\\vspace{25pt}\n\\hrule\n\n::: {#prerequisites .callout-important}\n*Before you begin, we expect participants to have a basic working knowledge of R.\nIf you are new to R or need a refresher, we recommend reviewing the earlier\nsessions on [data visualization](https://ammnet.github.io/ammnet-hackathon/posts/data-vis/)\nand [data wrangling](https://ammnet.github.io/ammnet-hackathon/posts/data-wrangle/).*\n\n*No prior experience with geographic data cleaning is required. However,\nfamiliarity with the previous [mapping in R](https://ammnet.github.io/ammnet-hackathon/posts/mapping-r/)\nsession will be useful. In this session, we focus on systematic approaches to\ngeographic name standardisation. You will learn how to detect mismatches,\napply string-distance algorithms, use interactive review for ambiguous cases,\nand build a reusable cache of corrections for future datasets.*\n:::\n\n## Overview\n\nWelcome back! In this post, we turn our attention to one of the most persistent challenges in public health data management: cleaning and standardising geographic names.\n\nWe’ll start with a quick look at why mismatched names create problems in analysis, reporting, and decision-making. From there, we’ll walk through a structured approach to name cleaning using the `sntutils::prep_geonames()` function. Along the way, we’ll explore common issues in real datasets, how\nstring-distance algorithms can suggest likely matches, and how to integrate human review only where it is needed.\n\nBy the end of this session, you’ll understand how to move from manual, ad hoc fixes to a reproducible workflow that scales from hundreds to tens of thousands of records. You’ll also see how caching, auditing, and match statistics make the process faster, more transparent, and easier to trust.\n\n::: {#learning-objectives .callout-note}\n**Learning Objectives**\n\nBy the end of this session, you will be able to:\n\n- Understand the nature of geographic name inconsistencies and their impact on\n  data quality.\n- Detect and standardise geographic names across multiple datasets.\n- Use interactive tools to review and resolve ambiguous matches.\n- Handle edge cases by correcting parent-level misassignments before\n  matching.\n- Save and re-use corrections through a persistent caching system.\n- Validate the quality of name matching with summary statistics.\n- Produce simple visualisations to confirm that geographic names align with\n  official boundaries.\n:::\n\n## The challenge of name matching\n\nGeographic names are rarely consistent across datasets. The same administrative\nunit may appear with different spellings, formats, or even linked to the wrong\nparent. These problems are common in routine health data, survey microdata, and\nsometimes even in official shapefiles.\n\nWhen names do not match, joins fail and indicators misalign. This leads to\nduplicate units in summaries, broken time series when names switch, and wrong\ndenominators in coverage estimates. Analysts spend more time fixing data than\nanalysing it, and programme teams lose trust in the results.\n\n### Two types of problems\n\nIt is important to distinguish between two categories:\n\n**1. Name inconsistencies**\nThese are technical issues that can be addressed with systematic cleaning.\nExamples include:\n\n- Spelling variations (*`Kadunna`* vs *`Kaduna`*).\n- Case inconsistencies (*`KANO`* vs *`Kano`*).\n- Extra whitespace or hidden characters (*` L agos `* vs *`Lagos`*).\n- Abbreviations and aliases (*`FCT`* vs *`Federal Capital Territory`*).\n- Language differences (local vs English/French names).\n- Parent misassignments (district linked to the wrong region).\n\n**2. Administrative changes**\nThese are structural changes that cannot be solved by name cleaning alone.\nExamples include:\n\n- New districts created (splits).\n- Old districts merged or dissolved.\n- Boundaries re-drawn to shift populations between units.\n- Renaming linked to political or administrative reforms.\n\nThe first set of problems can be handled with a reproducible name-matching\nworkflow. The second set requires authoritative boundary data and programme-\nlevel decisions on how to manage new or obsolete units. **This section focuses\nonly on the first category—fixing names**.\n\n### Why manual cleaning fails\n\nManual cleaning is often the default approach, but it does not scale well as\ndatasets grow. Common issues include:\n\n- **Error-prone.** Fatigue leads to inconsistent fixes.\n- **Inconsistent.** Different analysts handle the same issue differently.\n- **Non-reproducible.** Corrections exist only in local files or memory.\n- **Time-consuming.** Large datasets take hours or days to clean.\n- **Lost knowledge.** Corrections disappear when staff leave.\n- **Unverifiable.** Hard to track what was changed, when, or by whom.\n\nSome teams try to improve this by coding row-by-row replacements. While more\nsystematic than manual edits, this approach is still limited:\n\n- Hard-coded fixes apply only to one dataset.\n- Scripts become brittle and difficult to maintain.\n- Overlapping fixes spread across multiple files.\n- No single auditable record of decisions exists.\n\nThe result is that each new dataset restarts the cycle of ad hoc corrections.\nThe same names are fixed again and again, creating extra effort for analysts,\nlimited reproducibility, and reduced confidence in outputs. Public health data\nsystems need to be auditable—analysts should be able to show *how* a name was\nstandardised, *who* made the decision, and *when* it was applied. Without a\nstructured workflow, results differ each time, cannot be peer-reviewed, and\ndo not build cumulative institutional knowledge.\n\n### Why structured approaches are needed\n\nThe challenges of name matching highlight the importance of moving beyond\none-off fixes. Ad hoc edits may solve immediate problems but do not create\nreproducible or scalable workflows. A more systematic approach is needed—one\nthat records decisions, reduces duplication of effort, and makes the process\nauditable.\n\nSuch approaches provide a reproducible way to handle recurring issues in name\nstandardisation. They reduce the need for repeated ad hoc fixes and strengthen\nconfidence in analytical outputs.\n\n## Step-by-step Guide\n\nIn this session we present `prep_geonames()`, which illustrates how a\nstructured workflow can be applied in practice.\n\nKey elements include:\n\n- Algorithms to suggest likely matches.\n- Interactive review to resolve ambiguous cases.\n- A persistent record or cache of accepted decisions.\n- Match statistics and exports to support transparency.\n- Simple validation checks or visualisations to confirm consistency.\n\nAs an example, we use the 2018 DHS dataset to map the modelled percentage of the population without basic water in Nigeria at the `adm2` level. To ensure a reliable join, we align DHS administrative names with the WHO ADM2 shapefile through hierarchy-aware matching, cached decisions, and correction of parent misassignments. This process standardises spelling and boundary labels so that all DHS `adm1` and `adm2` entries match the WHO reference. We validate the result using unmatched-case checks and a map overlay, confirming a complete join with no missing polygons. The workflow is transparent, auditable, and reusable across DHS indicators and other datasets.\n\n### Step 1: Install packages\n\nIn the following steps we use `prep_geonames()`, which is part of\n[sntutils](https://github.com/ahadi-analytics/sntutils/tree/master), an R\npackage by AHADI to support Subnational Tailoring (SNT) of malaria\ninterventions. The package provides a number of helper functions for preparing, cleaning, and\nanalysing data to support decision-making at district level and below.\n\nTo install `sntutils` and a number of other packages (`dplyr`, `ggplot2` etc.,), we first need the `pak` package. `pak` makes it easy to install R packages, including development versions from GitHub, along with\ntheir dependencies.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1) install pak\ninstall.packages(\"pak\")\n\n# 2) install packages\npak::pkg_install(\n  c(\n    \"dplyr\",        # data manipulation\n    \"here\",         # for relative file paths\n    \"ggplot2\",      # plotting\n    \"cli\",          # console alerts/messages\n    \"grid\",         # unit sizing for plot theme elements\n    \"ahadi-analytics/sntutils\" # for prep_geoname and other helpers\n  ),\n  dependencies = TRUE\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n### Step 2: Load data\n\nFor this example we use modeled data from the 2018 Nigeria DHS, available\nthrough the [DHS Local Data Mapping Tool](https://spatialdata.dhsprogram.com/local-data-mapping-tool).\nEach download includes indicator tables, population counts, uncertainty\nintervals, and shapefiles. Here we use the Admin 2 tables and shapefiles,\nspecifically the estimates and confidence intervals for the population\nwithout basic water. The dataset has been slightly modified with intentional\nname inconsistencies to demonstrate the cleaning workflow.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# import data\nnga_dhs <- sntutils::read(\n  here::here(\"01_data/dhs/Admin2_NGDHS2018Table.xlsx\")\n) |>\n  dplyr::select(\n    adm0 = adm0_name,\n    adm1 = adm1_name,\n    adm2 = adm2_name,\n    pop_no_basic_water_value = nobaswatv, # % without basic water\n    pop_no_basic_water_ci_lower = nobaswatl, # % without basic water lower CI\n    pop_no_basic_water_ci_upper = nobaswatu # % without basic water upper CI\n  )\n\n# check the data\ndplyr::glimpse(nga_dhs)\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 774\nColumns: 6\n$ adm0                        <chr> \"Nigeria\", \"Nigeria\", \"Nigeria\", \"Nigeria\"…\n$ adm1                        <chr> \"Abia\", \"Abia\", \"Abia\", \"Abia\", \"Abia\", \"A…\n$ adm2                        <chr> \"Arochukwu\", \"Bende\", \"Ikwuano\", \"Ohafia\",…\n$ pop_no_basic_water_value    <dbl> 26.20, 27.94, 26.33, 26.05, 27.44, 17.98, …\n$ pop_no_basic_water_ci_lower <dbl> 8.92, 11.58, 8.26, 10.87, 7.99, 4.30, 6.24…\n$ pop_no_basic_water_ci_upper <dbl> 54.22, 48.40, 49.39, 48.69, 59.50, 42.94, …\n```\n\n\n:::\n:::\n\n\n\n:::\n\nWe also need a reference shapefile of administrative boundaries. For this example we use publicly available WHO ADM2 data, which can be accessed from\nthe [WHO ArcGIS service](https://services.arcgis.com/5T5nSi527N4F7luB/ArcGIS/rest/services/Detailed_Boundary_ADM2/FeatureServer), here we use `sntutils` to download it.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get/load NGA shapefile (WHO)\nnga_shp <- sntutils::download_shapefile(\n  country_codes = \"NGA\",\n  admin_level = \"adm2\",\n  dest_path = here::here(\"01_data/shapefile\")\n)\n\n# check shapefile\ndplyr::glimpse(nga_shp)\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 774\nColumns: 7\n$ adm0_code  <chr> \"NGA\", \"NGA\", \"NGA\", \"NGA\", \"NGA\", \"NGA\", \"NGA\", \"NGA\", \"NG…\n$ adm0       <chr> \"NIGERIA\", \"NIGERIA\", \"NIGERIA\", \"NIGERIA\", \"NIGERIA\", \"NIG…\n$ adm1       <chr> \"JIGAWA\", \"ZAMFARA\", \"BAYELSA\", \"LAGOS\", \"ABIA\", \"BAYELSA\",…\n$ adm2       <chr> \"MIGA\", \"GUSAU\", \"NEMBE\", \"EPE\", \"UMUAHIA SOUTH\", \"SAGBAMA\"…\n$ start_date <date> 2000-01-01, 2000-01-01, 2000-01-01, 2000-01-01, 2000-01-01…\n$ end_date   <date> 9999-12-31, 9999-12-31, 9999-12-31, 9999-12-31, 9999-12-31…\n$ geom       <MULTIPOLYGON [°]> MULTIPOLYGON (((9.71926 12...., MULTIPOLYGON (…\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### Step 3: Check matches\n\nBefore running any cleaning, inspect how well your dataset matches the reference shapefile (`lookup_data`). Use `sntutils::calculate_match_stats()` to summarise matches by level.\n\nThe function is hierarchy-aware. To check or match at `adm2`, you must also provide `adm1` and `adm0`. Column names must be identical in both datasets. The same rule applies at finer levels (e.g., `adm3`, settlements): you must include all higher levels. If your target data use `adm0/adm1/adm2`, your `lookup_data` must use the same names. The same rules apply later in `prep_geonames()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check matches\nsntutils::calculate_match_stats(\n  nga_dhs,\n  lookup_data = nga_shp,\n  level0 = \"adm0\",\n  level1 = \"adm1\",\n  level2 = \"adm2\"\n)\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Match Summary:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm0 (level 0): 1 out of 1 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm1 (level 1): 36 out of 37 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm2 (level 2): 698 out of 774 matched\n```\n\n\n:::\n:::\n\n\n\n:::\n\nAll country names in `nga_dhs` matched those in `nga_shp`. At the `adm1` level, 36 of 37 states matched. At the `adm2` level, 698 of 774 districts matched.\n\n### Step 4: Start matching\n\n#### Step 4.1: Use the shapefile as the reference\n\nWe will harmonise the admin names in the target table (`nga_dhs`) to the\nofficial shapefile (`nga_shp`) with `sntutils::prep_geonames()`. The function is\nhierarchy-aware and proceeds top–down (`adm0` → `adm1` → `adm2`). At each level\nit applies robust text preprocessing (uppercasing, accent removal, whitespace\nnormalisation, punctuation handling) and uses string-distance methods to\nsuggest likely matches within the correct parent context (e.g., `adm2` only\ncompares within the same `adm1`).\n\nKey benefits of `prep_geonames()`:\n\n- Works across up to six levels (`level0`–`level5`).\n- Restricts comparisons within parents (contextually correct candidates).\n- Caches decisions via `cache_path` so future runs automatically reuse prior\n  corrections and can be shared across analysts for consistency.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# path to cache\ncache_path <- here::here(\"01_data/cache/geoname_cleaning_nga.rds\")\nunmatched_path <- here::here(\"01_data/cache/nga_unmatched_adm2.rds\")\n\n# 2) Run interactive, hierarchy-based matching\nnga_dhs_cleaned <- sntutils::prep_geonames(\n  target_df = nga_dhs,   # data to be harmonised\n  lookup_df = nga_shp,   # authoritative reference\n  level0 = \"adm0\",\n  level1 = \"adm1\",\n  level2 = \"adm2\",\n  cache_path = cache_path,\n  interactive = TRUE\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\nYou can set `interactive = FALSE` to run in a non‑interactive mode.This ensures headless runs proceed without interactive prompts. When a cache is available, decisions are applied automatically; when it is absent, the code\nleaves names unchanged and continues.\n\nBelow is a short video demonstrating the `prep_geonames()` interface and how it\ncan be used to clean administrative names interactively.\n\n<video width=\"100%\" height=\"100%\" controls>\n  <source src=\"assets/videos/orig_prepgeoname.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>\n\n#### Step 4.2: What gets fixed and how caching helps\n\n`prep_geonames()` typically resolves issues like spelling, spacing, and\nformatting while honouring the administrative hierarchy.\n\nAll interactive decisions are written to the cache (`here::here(\"01_data/cache/geoname_cleaning_nga.rds\")` in this training). The\ncache records: the admin level, the original name, the chosen replacement from\nthe lookup, the full path of the matched hierarchy, the timestamp, and the\ndecision maker. Re‑running the function on updated data reuses those decisions\nautomatically, which saves time and ensures consistent naming across analysts.\n\n#### Step 4.3: Verify the final join with the shapefile\n\nAfter harmonisation, confirm that the cleaned table aligns fully with the shapefile structure. Recalculate match stats and check for any remaining unmatched rows.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1) Recompute match statistics\nsntutils::calculate_match_stats(\n  nga_dhs_cleaned,\n  lookup_data = nga_shp,\n  level0 = \"adm0\",\n  level1 = \"adm1\",\n  level2 = \"adm2\"\n)\n\n# 2) Explicit unmatched check via anti-join\nunmatched_after <- dplyr::anti_join(\n  dplyr::distinct(nga_dhs_cleaned, adm0, adm1, adm2),\n  dplyr::distinct(nga_shp, adm0, adm1, adm2),\n  by = c(\"adm0\", \"adm1\", \"adm2\")\n)\n\nif (nrow(unmatched_after) == 0) {\n  cli::cli_alert_success(\n    \"All admin units in the target now match the shapefile.\"\n  )\n} else {\n  cli::cli_alert_warning(\n    paste0(nrow(unmatched_after), \" admin units still need attention.\")\n  )\n  unmatched_after\n}\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Match Summary:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm0 (level 0): 1 out of 1 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm1 (level 1): 37 out of 37 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm2 (level 2): 774 out of 774 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n✔ All admin units in the target now match the shapefile.\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\nAll country names in `nga_dhs` matched those in `nga_shp`. At the `adm1` level, 37 of 37 states matched. At the `adm2` level, 774 of 774 districts matched. Which means our name matching workflow worked.\n\n#### Step 4.4: Review and inspect the cache\n\nWith the interactive, stratified matching complete, all units should now align. A small remainder may still be unmatched. Combining geographic constraints with human validation is effective and leaves fewer edge cases.\n\nThe cache is both a validation record and a reusable resource. It captures decisions made during the matching process, including confirmation of matches with local knowledge, resolution of ambiguous or misassigned units, alignment with national naming standards, and documentation that supports future harmonisation. The snippet below shows how to read and inspect the saved\ncache (`cache_path`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get cache file\ncache_df <- readRDS(cache_path)\n\n# print cache\nprint(cache_df)\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-2df270ab6ba27d9b7577\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-2df270ab6ba27d9b7577\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"caption\":\"<caption>Table: Cached geoname decisions saved during matching<\\/caption>\",\"data\":[[\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level2\",\"level1\",\"level1\",\"level1\"],[\"KOTON-KARFE\",\"OBOMA NGWA\",\"TALATA-MAFARA\",\"BIRNIN-MAGAJI/KIYAW\",\"TARMUWA\",\"BADE\",\"PORT HARCOURT\",\"OPOBO /NKORO\",\"OGU /BOLO\",\"OGBA/ EGBEMA/ NDONI\",\"AKUKU-TORU\",\"ABUA /ODUAL\",\"ORI-IRE\",\"IBADAN SOUTH-WEST\",\"IBADAN SOUTH-EAST\",\"IBADAN NORTH-WEST\",\"IBADAN NORTH-EAST\",\"OLA-OLUWA\",\"ODO-OTIN\",\"ATAKUMOSA WEST\",\"ATAKUMOSA EAST\",\"AIYEDAADE\",\"ILE-OLUJI/OKEIGBO\",\"ESE-ODO\",\"AKOKO SOUTH-WEST\",\"AKOKO SOUTH-EAST\",\"AKOKO NORTH-WEST\",\"AKOKO NORTH-EAST\",\"REMO-NORTH\",\"OBAFEMI-OWODE\",\"IMEKO-AFON\",\"IJEBU-ODE\",\"IJEBU NORTH-EAST\",\"EGBADO /YEWA SOUTH\",\"EGBADO /YEWA NORTH\",\"NASSARAWA EGON\",\"NASSARAWA\",\"ETI-OSA\",\"AJEROMI/ IFELODUN\",\"OKE-ERO\",\"OGORI/ MAGONGO\",\"KABBA /BUNU\",\"DANKO WASAGU\",\"BIRNIN-KEBBI\",\"DUTSINMA\",\"DANMUSA\",\"UNGOGO\",\"TUNDUN WADA\",\"SULE TANKARKAR\",\"KIRI KASAMMA\",\"OHAJI /EGBEMA\",\"EZINIHITTE MBAISE\",\"EHIME-MBANO\",\"IGBO-EZE SOUTH\",\"IGBO-EZE NORTH\",\"ISE /ORUN\",\"GBOYIN\",\"IGUEBEN\",\"ESAN NORTH-EAST\",\"NDOKWA  EAST\",\"OGBADIGBO\",\"KATSINA- ALA\",\"URUE OFFONG /ORUKO\",\"LAMURDE\",\"GIRIE\",\"ABUJA MUNICIPAL\",\"UMUAHIA  NORTH\",\"ISIALA NGWA SOUTH\",\"ISIALA NGWA NORTH\",\"OYOO\",\"KAYNO\",\"FCT-ABUJA\"],[\"KOGI\",\"OBI NWGA\",\"TALATA MAFARA\",\"BIRNIN MAGAJI/KIYAW\",\"TARMUA\",\"BARDE\",\"PORT-HARCOURT\",\"OPOBO/NKORO\",\"OGU BOLO\",\"OGBA/EGBEMA/NDONI\",\"AKUKU TORU\",\"ABUA/ODUAL\",\"ORI IRE\",\"IBADAN SOUTH WEST\",\"IBADAN SOUTH EAST\",\"IBADAN NORTH WEST\",\"IBADAN NORTH EAST\",\"OLA OLUWA\",\"ODO OTIN\",\"ATAKUNMOSA WEST\",\"ATAKUNMOSA EAST\",\"AIYEDADE\",\"ILE OLUJI/OKEIGBO\",\"ESE ODO\",\"AKOKO SOUTH WEST\",\"AKOKO SOUTH EAST\",\"AKOKO NORTH WEST\",\"AKOKO NORTH EAST\",\"REMO NORTH\",\"OBAFEMI OWODE\",\"IMEKO AFON\",\"IJEBU ODE\",\"IJEBU NORTH EAST\",\"EGBADO SOUTH\",\"EGBADO NORTH\",\"NASARAWA EGON\",\"NASARAWA\",\"ETI OSA\",\"AJEROMI/IFELODUN\",\"OKE ERO\",\"OGORI/MAGONGO\",\"KABBA/BUNU\",\"WASAGU/DANKO\",\"BIRNIN KEBBI\",\"DUTSIN MA\",\"DAN MUSA\",\"UNGONGO\",\"TUDUN WADA\",\"SULE TANKAKAR\",\"KIRI KASAMA\",\"OHAJI/EGBEMA\",\"EZINIHITTE\",\"EHIME -MBANO\",\"IGBO-EZE-SOUTH\",\"IGBO-EZE-NORTH\",\"ISE/ORUN\",\"GBONYIN\",\"IGUEGBEN\",\"ESAN  NORTH-EAST\",\"NDOKWA EAST\",\"OGBADIBO\",\"KATSINA-ALA\",\"URUE OFFONG/ORUKO\",\"LARMURDE\",\"GIREI\",\"MUNICIPAL AREA COUNCIL\",\"UMUAHIA NORTH\",\"ISIALA-NGWA SOUTH\",\"ISIALA-NGWA NORTH\",\"OYO\",\"KANO\",\"FCT, ABUJA\"],[\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\"],[\"KOGI\",\"ABIA\",\"ZAMFARA\",\"ZAMFARA\",\"YOBE\",\"YOBE\",\"RIVERS\",\"RIVERS\",\"RIVERS\",\"RIVERS\",\"RIVERS\",\"RIVERS\",\"OYO\",\"OYO\",\"OYO\",\"OYO\",\"OYO\",\"OSUN\",\"OSUN\",\"OSUN\",\"OSUN\",\"OSUN\",\"ONDO\",\"ONDO\",\"ONDO\",\"ONDO\",\"ONDO\",\"ONDO\",\"OGUN\",\"OGUN\",\"OGUN\",\"OGUN\",\"OGUN\",\"OGUN\",\"OGUN\",\"NASARAWA\",\"NASARAWA\",\"LAGOS\",\"LAGOS\",\"KWARA\",\"KOGI\",\"KOGI\",\"KEBBI\",\"KEBBI\",\"KATSINA\",\"KATSINA\",\"KANO\",\"KANO\",\"JIGAWA\",\"JIGAWA\",\"IMO\",\"IMO\",\"IMO\",\"ENUGU\",\"ENUGU\",\"EKITI\",\"EKITI\",\"EDO\",\"EDO\",\"DELTA\",\"BENUE\",\"BENUE\",\"AKWA IBOM\",\"ADAMAWA\",\"ADAMAWA\",\"FCT, ABUJA\",\"ABIA\",\"ABIA\",\"ABIA\",\"OYO\",\"KANO\",\"FCT, ABUJA\"],[\"KOGI\",\"OBI NWGA\",\"TALATA MAFARA\",\"BIRNIN MAGAJI/KIYAW\",\"TARMUA\",\"BARDE\",\"PORT-HARCOURT\",\"OPOBO/NKORO\",\"OGU BOLO\",\"OGBA/EGBEMA/NDONI\",\"AKUKU TORU\",\"ABUA/ODUAL\",\"ORI IRE\",\"IBADAN SOUTH WEST\",\"IBADAN SOUTH EAST\",\"IBADAN NORTH WEST\",\"IBADAN NORTH EAST\",\"OLA OLUWA\",\"ODO OTIN\",\"ATAKUNMOSA WEST\",\"ATAKUNMOSA EAST\",\"AIYEDADE\",\"ILE OLUJI/OKEIGBO\",\"ESE ODO\",\"AKOKO SOUTH WEST\",\"AKOKO SOUTH EAST\",\"AKOKO NORTH WEST\",\"AKOKO NORTH EAST\",\"REMO NORTH\",\"OBAFEMI OWODE\",\"IMEKO AFON\",\"IJEBU ODE\",\"IJEBU NORTH EAST\",\"EGBADO SOUTH\",\"EGBADO NORTH\",\"NASARAWA EGON\",\"NASARAWA\",\"ETI OSA\",\"AJEROMI/IFELODUN\",\"OKE ERO\",\"OGORI/MAGONGO\",\"KABBA/BUNU\",\"WASAGU/DANKO\",\"BIRNIN KEBBI\",\"DUTSIN MA\",\"DAN MUSA\",\"UNGONGO\",\"TUDUN WADA\",\"SULE TANKAKAR\",\"KIRI KASAMA\",\"OHAJI/EGBEMA\",\"EZINIHITTE\",\"EHIME -MBANO\",\"IGBO-EZE-SOUTH\",\"IGBO-EZE-NORTH\",\"ISE/ORUN\",\"GBONYIN\",\"IGUEGBEN\",\"ESAN  NORTH-EAST\",\"NDOKWA EAST\",\"OGBADIBO\",\"KATSINA-ALA\",\"URUE OFFONG/ORUKO\",\"LARMURDE\",\"GIREI\",\"MUNICIPAL AREA COUNCIL\",\"UMUAHIA NORTH\",\"ISIALA-NGWA SOUTH\",\"ISIALA-NGWA NORTH\",null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[\"2025-09-01 10:51:19 UTC\",\"2025-09-01 10:50:26 UTC\",\"2025-09-01 10:42:32 UTC\",\"2025-09-01 10:42:30 UTC\",\"2025-09-01 10:42:28 UTC\",\"2025-09-01 10:42:26 UTC\",\"2025-09-01 10:42:25 UTC\",\"2025-09-01 10:42:22 UTC\",\"2025-09-01 10:42:20 UTC\",\"2025-09-01 10:42:18 UTC\",\"2025-09-01 10:42:17 UTC\",\"2025-09-01 10:42:15 UTC\",\"2025-09-01 10:42:13 UTC\",\"2025-09-01 10:42:11 UTC\",\"2025-09-01 10:42:09 UTC\",\"2025-09-01 10:42:07 UTC\",\"2025-09-01 10:42:05 UTC\",\"2025-09-01 10:42:03 UTC\",\"2025-09-01 10:42:01 UTC\",\"2025-09-01 10:42:00 UTC\",\"2025-09-01 10:41:58 UTC\",\"2025-09-01 10:41:57 UTC\",\"2025-09-01 10:41:56 UTC\",\"2025-09-01 10:41:55 UTC\",\"2025-09-01 10:41:54 UTC\",\"2025-09-01 10:41:52 UTC\",\"2025-09-01 10:41:51 UTC\",\"2025-09-01 10:41:49 UTC\",\"2025-09-01 10:41:47 UTC\",\"2025-09-01 10:41:46 UTC\",\"2025-09-01 10:41:44 UTC\",\"2025-09-01 10:41:43 UTC\",\"2025-09-01 10:41:41 UTC\",\"2025-09-01 10:41:40 UTC\",\"2025-09-01 10:41:38 UTC\",\"2025-09-01 10:41:36 UTC\",\"2025-09-01 10:41:35 UTC\",\"2025-09-01 10:41:33 UTC\",\"2025-09-01 10:41:31 UTC\",\"2025-09-01 10:41:29 UTC\",\"2025-09-01 10:41:27 UTC\",\"2025-09-01 10:41:13 UTC\",\"2025-09-01 10:41:12 UTC\",\"2025-09-01 10:41:06 UTC\",\"2025-09-01 10:41:04 UTC\",\"2025-09-01 10:41:03 UTC\",\"2025-09-01 10:41:02 UTC\",\"2025-09-01 10:41:00 UTC\",\"2025-09-01 10:40:59 UTC\",\"2025-09-01 10:40:57 UTC\",\"2025-09-01 10:40:56 UTC\",\"2025-09-01 10:40:55 UTC\",\"2025-09-01 10:40:54 UTC\",\"2025-09-01 10:40:52 UTC\",\"2025-09-01 10:40:51 UTC\",\"2025-09-01 10:40:50 UTC\",\"2025-09-01 10:40:49 UTC\",\"2025-09-01 10:40:48 UTC\",\"2025-09-01 10:40:47 UTC\",\"2025-09-01 10:40:45 UTC\",\"2025-09-01 10:40:44 UTC\",\"2025-09-01 10:40:42 UTC\",\"2025-09-01 10:40:41 UTC\",\"2025-09-01 10:40:40 UTC\",\"2025-09-01 10:40:39 UTC\",\"2025-09-01 10:40:38 UTC\",\"2025-09-01 10:40:35 UTC\",\"2025-09-01 10:39:53 UTC\",\"2025-09-01 10:39:51 UTC\",\"2025-09-01 10:39:49 UTC\",\"2025-09-01 10:39:46 UTC\",\"2025-09-01 10:39:44 UTC\"],[\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\",\"mohamedyusuf\"]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>level<\\/th>\\n      <th>name_to_match<\\/th>\\n      <th>replacement<\\/th>\\n      <th>level0_prepped<\\/th>\\n      <th>level1_prepped<\\/th>\\n      <th>level2_prepped<\\/th>\\n      <th>level3_prepped<\\/th>\\n      <th>level4_prepped<\\/th>\\n      <th>created_time<\\/th>\\n      <th>name_of_creator<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"scrollY\":\"400px\",\"scrollX\":true,\"info\":false,\"columnDefs\":[{\"name\":\"level\",\"targets\":0},{\"name\":\"name_to_match\",\"targets\":1},{\"name\":\"replacement\",\"targets\":2},{\"name\":\"level0_prepped\",\"targets\":3},{\"name\":\"level1_prepped\",\"targets\":4},{\"name\":\"level2_prepped\",\"targets\":5},{\"name\":\"level3_prepped\",\"targets\":6},{\"name\":\"level4_prepped\",\"targets\":7},{\"name\":\"created_time\",\"targets\":8},{\"name\":\"name_of_creator\",\"targets\":9}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false},\"callback\":\"function(table) {\\ntable.columns().every(function(){\\n  this.nodes().to$().css({'white-space':'nowrap'});\\n});\\ntable.table().header().querySelectorAll('th').forEach(function(th){\\n  th.style.whiteSpace = 'nowrap';\\n});\\n}\"},\"evals\":[\"callback\"],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n:::\n\nYou can reuse this cache on future datasets with the same geography by pointing\n`cache_path` to the shared file and running with `interactive = FALSE` for\nheadless execution.\n\n### Step 5: Edge case — fix parent level before matching\n\nSometimes an `adm2` is attached to the wrong `adm1` in the source table. Because `prep_geonames()` restricts candidates within the parent, a wrong parent prevents a match. The fix is to amend the parent level up front (with a reproducible rule) and then run matching.\n\nBelow we import a new DHS dataset, similar to Step 2, but with a few edge cases where some `adm2` units are assigned to the wrong `adm1`.\n<!--\n create an amended version of the DHS table (`nga_dhs_edge`) using `dplyr::case_when()` to correct a few illustrative parent misassignments in the dummy example `Admin2_NGDHS2018Table.xlsx`. We then run `prep_geonames()` on this amended table and save the result as `nga_dhs_cleaned_edge`. -->\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# import edge case data\nnga_dhs_edge <- sntutils::read(\n  here::here(\"01_data/dhs/Admin2_NGDHS2018Table_edge.xlsx\")\n) |>\n  dplyr::select(\n    adm0 = adm0_name,\n    adm1 = adm1_name,\n    adm2 = adm2_name,\n    pop_no_basic_water_value = nobaswatv, # % without basic water\n    pop_no_basic_water_ci_lower = nobaswatl, # % without basic water lower CI\n    pop_no_basic_water_ci_upper = nobaswatu # % without basic water upper CI\n  )\n\n# check the matching of the stats of the edge case data\nsntutils::calculate_match_stats(\n  nga_dhs_edge,\n  lookup_data = nga_shp,\n  level0 = \"adm0\",\n  level1 = \"adm1\",\n  level2 = \"adm2\"\n)\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Match Summary:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm0 (level 0): 1 out of 1 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm1 (level 1): 36 out of 37 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm2 (level 2): 691 out of 774 matched\n```\n\n\n:::\n:::\n\n\n\n:::\n\nLet us try to match the names using our cache, setting `interactive = FALSE` and also setting up a path for `unmatched_export_path` so that we can save and inspect any admin names that we could not match.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1) set up path to save the unmatched admin names\nunmatched_path <- here::here(\"01_data/cache/nga_unmatched_adm2.rds\")\n\n# 2) run interactive, hierarchy-based matching\nnga_dhs_edge_cleaned <- sntutils::prep_geonames(\n  target_df = nga_dhs_edge, # data to be harmonised\n  lookup_df = nga_shp, # authoritative reference\n  level0 = \"adm0\",\n  level1 = \"adm1\",\n  level2 = \"adm2\",\n  cache_path = cache_path,\n  unmatched_export_path = unmatched_path,\n  interactive = FALSE\n)\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Match Summary:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm0 (level 0): 1 out of 1 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm1 (level 1): 37 out of 37 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm2 (level 2): 767 out of 774 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n✔ In non-interactive mode. Exiting after matching with cache...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n✔ Unmatched data exported to: 01_data/cache/nga_unmatched_adm2.rds\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Exported 7 unmatched rows for column \n```\n\n\n:::\n:::\n\n\n\n:::\n\nUsing our cache from the previous round of matching (Step 4.1), we were able to match 1 of the `adm1`, as well as the 75 mismatched `adm2`. However, we still have 7 `adm2` that we are unable to match.\n\nUsing the unmatched data export is very helpful in situations like these. It provides a dataset with an `unmatched_column`, the relevant context columns (e.g., `adm2` with its parent levels `adm0` and `adm1`), and additional metadata such as the lookup source, the target dataset, the user who performed the matching, and the timestamp.\n\nLet us import `unmatched_path` to check what these non-matched admins are.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get cache file\nunmatched_df <- readRDS(unmatched_path)\n\n# print cache\nprint(unmatched_df)\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-1f4d45d641a370b8b6aa\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-1f4d45d641a370b8b6aa\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"caption\":\"<caption>Table: Unmatched geoname to check<\\/caption>\",\"data\":[[\"adm2\",\"adm2\",\"adm2\",\"adm2\",\"adm2\",\"adm2\",\"adm2\"],[\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\",\"NIGERIA\"],[\"BORNO\",\"BORNO\",\"BORNO\",\"EDO\",\"EDO\",\"EDO\",\"EDO\"],[\"ETHIOPE WEST\",\"IKA NORTH EAST\",\"IKA SOUTH\",\"IKEDURU\",\"ISIALA MBANO\",\"MBATOLI\",\"NGOR-OKPALA\"],[\"nga_dhs_edge\",\"nga_dhs_edge\",\"nga_dhs_edge\",\"nga_dhs_edge\",\"nga_dhs_edge\",\"nga_dhs_edge\",\"nga_dhs_edge\"],[\"nga_shp\",\"nga_shp\",\"nga_shp\",\"nga_shp\",\"nga_shp\",\"nga_shp\",\"nga_shp\"],[\"2025-09-15T18:57:01Z\",\"2025-09-15T18:57:01Z\",\"2025-09-15T18:57:01Z\",\"2025-09-15T18:57:01Z\",\"2025-09-15T18:57:01Z\",\"2025-09-15T18:57:01Z\",\"2025-09-15T18:57:01Z\"],[\"jmillar\",\"jmillar\",\"jmillar\",\"jmillar\",\"jmillar\",\"jmillar\",\"jmillar\"]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>unmatched_column<\\/th>\\n      <th>adm0<\\/th>\\n      <th>adm1<\\/th>\\n      <th>adm2<\\/th>\\n      <th>target_data<\\/th>\\n      <th>lookup_data<\\/th>\\n      <th>created_time<\\/th>\\n      <th>name_of_creator<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"scrollY\":\"400px\",\"scrollX\":true,\"info\":false,\"columnDefs\":[{\"name\":\"unmatched_column\",\"targets\":0},{\"name\":\"adm0\",\"targets\":1},{\"name\":\"adm1\",\"targets\":2},{\"name\":\"adm2\",\"targets\":3},{\"name\":\"target_data\",\"targets\":4},{\"name\":\"lookup_data\",\"targets\":5},{\"name\":\"created_time\",\"targets\":6},{\"name\":\"name_of_creator\",\"targets\":7}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false},\"callback\":\"function(table) {\\ntable.columns().every(function(){\\n  this.nodes().to$().css({'white-space':'nowrap'});\\n});\\ntable.table().header().querySelectorAll('th').forEach(function(th){\\n  th.style.whiteSpace = 'nowrap';\\n});\\n}\"},\"evals\":[\"callback\"],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n:::\n\nWe can see seven `adm2` units that we couldn't match. Let us check these `adm2` in `nga_shp` to confirm they are under the correct `adm1`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get names of non‑matched adm2\nnonmatched_adm2 <- c(\n  \"ETHIOPE WEST\",\n  \"IKA NORTH EAST\",\n  \"IKA SOUTH\",\n  \"IKEDURU\",\n  \"ISIALA MBANO\",\n  \"MBATOLI\",\n  \"NGOR-OKPALA\"\n)\n\nnga_shp |>\n  dplyr::filter(adm2 %in% nonmatched_adm2) |>\n  dplyr::distinct(adm1, adm2)\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-799a3a88cbb2ebabd8e1\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-799a3a88cbb2ebabd8e1\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"caption\":\"<caption>Table: Checking Unmatched adm2 names in shapefile `nga_shp`<\\/caption>\",\"data\":[[\"DELTA\",\"DELTA\",\"DELTA\",\"IMO\",\"IMO\",\"IMO\",\"IMO\"],[\"IKA NORTH EAST\",\"ETHIOPE WEST\",\"IKA SOUTH\",\"ISIALA MBANO\",\"NGOR-OKPALA\",\"MBATOLI\",\"IKEDURU\"]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>adm1<\\/th>\\n      <th>adm2<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"scrollY\":\"400px\",\"scrollX\":true,\"info\":false,\"columnDefs\":[{\"name\":\"adm1\",\"targets\":0},{\"name\":\"adm2\",\"targets\":1}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false},\"callback\":\"function(table) {\\ntable.columns().every(function(){\\n  this.nodes().to$().css({'white-space':'nowrap'});\\n});\\ntable.table().header().querySelectorAll('th').forEach(function(th){\\n  th.style.whiteSpace = 'nowrap';\\n});\\n}\"},\"evals\":[\"callback\"],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n:::\n\nSo `ETHIOPE WEST`, `IKA NORTH EAST` and `IKA SOUTH` should be under `DELTA`. Meanwhile, `IKEDURU`, `ISIALA MBANO`, `MBATOLI` and `NGOR-OKPALA` should be under `IMO`.\n\nLet us correct these parent (`adm1`) misassignments (`nga_dhs_edge`) using `dplyr::case_when()`, and then attempt matching using our previous `cache_path`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define sets of adm2 that belong to specific adm1\ndelta_adm2 <- c(\n  \"ETHIOPE WEST\",\n  \"IKA NORTH EAST\",\n  \"IKA SOUTH\"\n)\n\nimo_adm2 <- c(\n  \"IKEDURU\",\n  \"ISIALA MBANO\",\n  \"MBATOLI\",\n  \"NGOR-OKPALA\"\n)\n\n# 1) fix parent (adm1) misassignments reproducibly\nnga_dhs_edge_fixed <- nga_dhs_edge_cleaned |>\n  dplyr::mutate(\n    adm1 = dplyr::case_when(\n      adm2 %in% delta_adm2 ~ \"DELTA\",\n      adm2 %in% imo_adm2 ~ \"IMO\",\n      TRUE ~ adm1\n    )\n  )\n\n# 2) re-run matching using the cache (non-interactive)\nnga_dhs_edge_cleaned <- sntutils::prep_geonames(\n  target_df = nga_dhs_edge_fixed,\n  lookup_df = nga_shp,\n  level0 = \"adm0\",\n  level1 = \"adm1\",\n  level2 = \"adm2\",\n  cache_path = cache_path,\n  interactive = FALSE\n)\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Match Summary:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm0 (level 0): 1 out of 1 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm1 (level 1): 37 out of 37 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• adm2 (level 2): 774 out of 774 matched\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n✔ All records matched; process completed. Exiting...\n```\n\n\n:::\n:::\n\n\n\n:::\n\nAfter correcting the parent misassignments for seven `adm2` units, we reran the matching non‑interactively using the existing geoname cache. The cached decisions applied cleanly to `nga_dhs_edge_cleaned`, and all units now align with the WHO ADM2 shapefile; both `adm1` and `adm2` report full matches (`unmatched = 0`). With the hierarchy fixed and names harmonised, we can move on to the map‑based validation in Step 6.\n\n### Step 6: Validate with a map (join to shapefile)\n\nAs a final validation, join the cleaned table to the shapefile and visualise `pop_no_basic_water_value` by `adm2`. Any grey/NA areas indicate unmatched units.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1) join cleaned data to shapefile at adm2\nnga_map <- nga_shp |>\n  dplyr::left_join(\n    nga_dhs_edge_cleaned |>\n      dplyr::select(adm0, adm1, adm2, pop_no_basic_water_value),\n    by = c(\"adm0\", \"adm1\", \"adm2\")\n  )\n\n# 2) quick NA check on the indicator\nn_na <- sum(is.na(nga_map$pop_no_basic_water_value))\ncli::cli_alert_info(\n  paste0(n_na, \" polygons have no indicator value (NA).\")\n)\n\n# 3) plot map\np <- ggplot2::ggplot(nga_map) +\n  ggplot2::geom_sf(\n    ggplot2::aes(fill = pop_no_basic_water_value),\n    color = NA,\n    linewidth = 0\n  ) +\n  ggplot2::scale_fill_viridis_c(\n    option = \"A\",\n    direction = -1,\n    name = \"% without basic water\"\n  ) +\n  ggplot2::labs(\n    title = \"Nigeria: Population without basic water (DHS 2018, adm2)\",\n    subtitle = \"Joined using cleaned names (`nga_dhs_edge_cleaned`)\",\n    caption = \"Source: DHS Local Data Mapping Tool; WHO ADM2 boundaries\"\n  ) +\n  ggplot2::theme_void() +\n  ggplot2::theme(\n    plot.title = ggplot2::element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    legend.key.width = grid::unit(1, \"cm\"),\n    legend.justification = c(0, 0)\n  )\n\n# save plot\nggplot2::ggsave(\n  plot = p,\n  filename = \"03_outputs/validation_map.png\"\n)\n\n# check plot\nprint(p)\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Output\" icon=\"false\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ 0 polygons have no indicator value (NA).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/map-validation-1.png){width=768}\n:::\n:::\n\n\n\n:::\n\nIf the workflow is executed correctly, the `NA` count should be 0 and there should be no grey polygons; this indicates that cleaned DHS units align with the shapefile and the indicator values are attached successfully.\n\n## Summary\n\nBy following this workflow, you will align DHS administrative names to the WHO ADM2 shapefile using hierarchy‑aware matching, reuse cached decisions, and correct parent misassignments where needed. This should standardise spelling and boundary labelling so that all DHS `adm1` and `adm2` entries match the WHO reference. Final checks using unmatched‑case statistics and a map overlay will confirm whether the join is clean (no `NA` polygons). The approach is reproducible, auditable, and reusable across DHS indicators and other datasets.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.34.0/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}